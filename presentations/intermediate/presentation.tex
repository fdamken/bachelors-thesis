% !TeX spellcheck = en_US
% !TeX program = lualatex


% Do not surround the equal signs with spaces, it causes errors!
\documentclass[
	aspectratio=43,
	color={accentcolor=1c},
	logo=false,
	colorframetitle=true,
]{tudabeamer}

% Include preamble to not clutter this file.
\input{preamble/packages}
\input{preamble/styles}


\title{Variational Autoenconders for Koopman Dynamical Systems}
\subtitle{B.Sc. Intermediate Presentation}
\author{Fabian Damken}
\department{Department of Computer Science}
\institute{Intelligent Autonomous Systems}
\date{\today}

\logo*{\includegraphics{./img/iasLogo}}

% TODO: Add title graphic here.
\titlegraphic*{\includegraphics{example-image}}


\begin{document}
	\maketitle

	\begin{frame}{Motivation}
		\begin{itemize}
			\item Control theory for linear systems is highly evolved.
			\item But nonlinear systems are hard\dots
			\item We need ways to linearize a nonlinear system!
			\item "Classical" Linearization:
				\begin{itemize}
					\item Use small angle approximation (e.g. for pendulum)?
					\item Diverge fast with higher displacements\dots
					\item Only linearize locally, not globally!
				\end{itemize}
		\end{itemize}
	\end{frame}

	\begin{frame}{The Koopman Operator}
		For a \emph{nonlinear} dynamical system
		\begin{align*}
			\vec{s}_{t + 1} = \vec{F}(\vec{s}_{t})
		\end{align*}
		with \emph{nonlinear} measurements (and \emph{embedding})
		\begin{align*}
			\vec{y}_t = \vec{g}(\vec{s}_t)
		\end{align*}
		the Koopman operator advances these measurements forward in time \emph{linearly}:
		\begin{align*}
			\vec{g}(\vec{s}_{t + 1}) = \mathcal{K} \vec{g}(\vec{s}_t)
			\quad\iff\quad
			\vec{y}_{t + 1} = \mathcal{K} \vec{y}_t
		\end{align*}

		This is possible for every nonlinear dynamical system! And globalizes linearly! But the embedding \(\vec{g}\) is typically infinite-dimensional\dots
	\end{frame}

	\begin{frame}{Koopman Dynamical System ("Deterministic")}
		\begin{figure}
			\begin{tikzpicture}[->, state/.style = { draw, circle, minimum height = 1cm, minimum width = 1cm }, observation/.style = { draw, circle, minimum height = 1cm, minimum width = 1cm }]
				\node [state] (s1) {\(\vec{s}_{\,\mathclap{\,1}}\)};
				\node [state, right = 1 of s1] (s2) {\(\vec{s}_{\,\mathclap{\,2}}\)};
				\node [state, right = 1 of s2] (s3) {\(\vec{s}_{\,\mathclap{\,3}}\)};
				\node [minimum height = 1cm, right = 1 of s3] (sD) {\(\cdots\)};
				\node [state, right = 1 of sD] (sT) {\(\vec{s}_{\,\mathclap{\,T}}\)};

				\node [observation, below = 1 of s1] (y1) {\raisebox{-5pt}{\(\vec{y}_{\,\mathclap{\,1}}\)}};
				\node [observation, below = 1 of s2] (y2) {\(\vec{y}_{\,\mathclap{\,2}}\)};
				\node [observation, below = 1 of s3] (y3) {\(\vec{y}_{\,\mathclap{\,3}}\)};
				\node [minimum height = 1cm, below = 1 of sD] (yD) {\(\cdots\)};
				\node [observation, below = 1 of sT] (yT) {\(\vec{y}_{\,\mathclap{\,T}}\)};

				\draw (s1) -- node[above]{\(\vec{F}\)} (s2);
				\draw (s2) -- node[above]{\(\vec{F}\)} (s3);
				\draw (s3) -- node[above]{\(\vec{F}\)} (sD);
				\draw (sD) -- node[above]{\(\vec{F}\)} (sT);

				\draw (y1) -- node[below]{\(\mathcal{K}\)} (y2);
				\draw (y2) -- node[below]{\(\mathcal{K}\)} (y3);
				\draw (y3) -- node[below]{\(\mathcal{K}\)} (yD);
				\draw (yD) -- node[below]{\(\mathcal{K}\)} (yT);

				\draw (s1) to[bend right = 15] node[left]{\(\vec{g}\)} (y1);
				\draw (s2) to[bend right = 15] node[left]{\(\vec{g}\)} (y2);
				\draw (s3) to[bend right = 15] node[left]{\(\vec{g}\)} (y3);
				\draw (sT) to[bend right = 15] node[left]{\(\vec{g}\)} (yT);

				\draw [dashed] (y1) to[bend right = 15] node[right]{\(\vec{g}^{-1}\)} (s1);
				\draw [dashed] (y2) to[bend right = 15] node[right]{\(\vec{g}^{-1}\)} (s2);
				\draw [dashed] (y3) to[bend right = 15] node[right]{\(\vec{g}^{-1}\)} (s3);
				\draw [dashed] (yT) to[bend right = 15] node[right]{\(\vec{g}^{-1}\)} (sT);
			\end{tikzpicture}
			\caption{Adopted from Brunton et al. "Koopman Invariant Subspaces and Finite Linear Representations of Nonlinear Dynamical Systems for Control".}
		\end{figure}
	\end{frame}

	\begin{frame}{Linear Gaussian Dynamical System}
		\begin{figure}
			\begin{tikzpicture}[->, state/.style = { draw, circle, minimum height = 1cm, minimum width = 1cm }, observation/.style = { draw, circle, minimum height = 1cm, minimum width = 1cm }]
				\node [state] (s1) {\(\vec{s}_{\,\mathclap{\,1}}\)};
				\node [state, right = 1 of s1] (s2) {\(\vec{s}_{\,\mathclap{\,2}}\)};
				\node [state, right = 1 of s2] (s3) {\(\vec{s}_{\,\mathclap{\,3}}\)};
				\node [minimum height = 1cm, right = 1 of s3] (sD) {\(\cdots\)};
				\node [state, right = 1 of sD] (sT) {\(\vec{s}_{\,\mathclap{\,T}}\)};

				\node [observation, below = 1 of s1] (y1) {\raisebox{-5pt}{\(\vec{y}_{\,\mathclap{\,1}}\)}};
				\node [observation, below = 1 of s2] (y2) {\(\vec{y}_{\,\mathclap{\,2}}\)};
				\node [observation, below = 1 of s3] (y3) {\(\vec{y}_{\,\mathclap{\,3}}\)};
				\node [observation, below = 1 of sT] (yT) {\(\vec{y}_{\,\mathclap{\,T}}\)};

				\draw (s1) -- (s2);
				\draw (s2) -- (s3);
				\draw (s3) -- (sD);
				\draw (sD) -- (sT);

				\draw (s1) to[bend right = 15] (y1);
				\draw (s2) to[bend right = 15] (y2);
				\draw (s3) to[bend right = 15] (y3);
				\draw (sT) to[bend right = 15] (yT);

				\draw [dashed] (y1) to[bend right = 15] (s1);
				\draw [dashed] (y2) to[bend right = 15] (s2);
				\draw [dashed] (y3) to[bend right = 15] (s3);
				\draw [dashed] (yT) to[bend right = 15] (sT);
			\end{tikzpicture}
		\end{figure}

		\begin{equation*}
			\begin{aligned}
				\vec{s}_{t + 1} &= \eqmakebox[a][l]{\( \mat{A} \vec{s}_t + \vec{v}, \)}\quad \eqmakebox[b][r]{\( \vec{v} \)} \sim \normal(\vec{0}, \mat{Q}) \\
				\vec{y}_t &= \eqmakebox[a][l]{\( \vec{g}_{\vec{\theta}}(\vec{s}_t) + \vec{w}, \)}\quad \eqmakebox[b][r]{\( \vec{w} \)} \sim \normal(\vec{0}, \mat{R})
			\end{aligned}
			\qquad\iff\qquad
			\begin{aligned}
				\vec{s}_{t + 1} &\sim \normal(\mat{A} \vec{s}_t, \mat{Q}) \\
				\vec{y}_t &\sim \normal(\vec{g}_{\vec{\theta}}(\vec{s}_t), \mat{R})
			\end{aligned}
		\end{equation*}
	\end{frame}

	\begin{frame}{How to learn?}
		Goal: Estimate all of the following:
		\begin{itemize}
			\item Latent dynamics matrix \( \mat{A} \).
			\item Measurement function \( \vec{g}_{\vec{\theta}}(\cdot) \) (i.e. the parameters \( \vec{\theta} \)).
			\item Noise covariances \(\mat{Q}\), \(\mat{R}\).
		\end{itemize}
		We employ an EM-algorithm to do that!

		\begin{alertblock}{Core Problem}
			Some expectations cannot be evaluated in closed form for a nonlinear \( \vec{g}_{\vec{\theta}}(\cdot) \)!
		\end{alertblock}
	\end{frame}

	\begin{frame}{Approach for Solving the Core Problem}
		To evaluate the expectations, use cubature rules!

		Namely the spherical-radial cubature rule:
		\begin{align*}
			\E_{\vec{x} \,\sim\, \normal(\vec{\mu}, \mat{\Sigma})}\big[ \vec{f}(\vec{x}) \big] \approx \frac{1}{2n} \sum_{i = 1}^{2n} \vec{f}\Big(\! \sqrt{\mat{\Sigma}} \vec{\xi}_i + \vec{\mu} \Big),\quad \vec{\xi}_i = \sqrt{n} \cdot [\vec{1}]_i
		\end{align*}
	\end{frame}

	\begin{frame}{The M-Step: Maximizing the Likelihood}
		\begin{itemize}
			\item Latent dynamics matrix \(\mat{A}\) and covariances \(\mat{R}\) can be evaluated in closed form.
			\item Not possible for the measurement function parameters \( \vec{\theta} \)!
			\item[] \(\qquad\longrightarrow\quad\) Use backpropagation!
		\end{itemize}
	\end{frame}

	\section{Results}
		\subsection{The Pendulum}
			\begin{frame}{Results: Inverted Pendulum \\ Dynamical System}
				Equation of movement:
				\begin{align*}
					\ddot{\varphi} = \sin(\varphi)
				\end{align*}

				\begin{minipage}{0.49\textwidth}
					Observations:
					\begin{itemize}
						\item Displacement \tabto{2.5cm} \(\varphi\)
						\item Velocity     \tabto{2.5cm} \(\dot{\varphi}\)
					\end{itemize}
					\begin{figure}
						\centering
						\includegraphics[width=0.7\textwidth]{example-image}
						\caption{Plot of log-likelihood.} % TODO
					\end{figure}
				\end{minipage}
				\begin{minipage}{0.49\textwidth}
					\begin{figure}
						\centering
						\includegraphics[width=\textwidth]{example-image}
						\caption{Image of inverted pendulum.} % TODO
					\end{figure}
				\end{minipage}
			\end{frame}

%			\begin{frame}{Results: Inverted Pendulum \\ Log-Likelihood}
%				\vspace{-0.4cm}
%				\begin{figure}
%					\centering
%					\includegraphics[height = 0.85\textheight]{figures/results/pendulum/log-likelihood}
%				\end{figure}
%			\end{frame}

			\begin{frame}{Results: Inverted Pendulum \\ Rollout in Observation Space}
				\vspace{-0.4cm}
				\begin{figure}
					\centering
					\includegraphics[width = \textwidth]{figures/results/pendulum/rollout-observations.pdf}
				\end{figure}
			\end{frame}

			\begin{frame}{Results: Inverted Pendulum \\ Movement Prediction}
				\vspace{-0.4cm}
				\begin{figure}
					\centering
					\includegraphics[width = \textwidth]{figures/results/pendulum/predicted-observations.pdf}
				\end{figure}
			\end{frame}
		% end
	% end





	\appendix

	\section{Backup Slides} \sectionslide
		\subsection{Expectation Maximization}
			\begin{frame}{Expectation Maximization}
				\begin{itemize}
					\item E-Step: Calculate the expected latents and correlations using filtering/smoothing.
					\item M-Step: Maximize the expected log-likelihood \( \E\big[\! \ln p(\vec{s}_{1:T}, \vec{y}_{1:T}) \given \vec{y}_{1:T} \big] \).
				\end{itemize}
			\end{frame}
		% end

		\subsection{The Expected Log-Likelihood}
			\begin{frame}{The Expected Log-Likelihood}
				Markov property yields complete log-likelihood:
				\begin{align*}
					\ln p(\vec{s}_{1:T}, \vec{y}_{1:T}) = \ln p(\vec{s}_1) + \sum_{t = 2}^{T} \ln p(\vec{s}_{t + 1} \given \vec{s}_t) + \sum_{t = 1}^{T} \ln p(\vec{y}_t \given \vec{s}_t)
				\end{align*}
				Expectation \( \E\big[\! \ln p(\vec{s}_{1:T}, \vec{y}_{1:T}) \given \vec{y}_{1:T} \big] \) is based on five other expectations:
				\begin{align*}
					\hat{\vec{s}}_t \coloneqq \E\big[ \vec{s}_t \biggiven \vec{y}_{1:T} \big]
					\qquad
					\mat{P}_t \coloneqq \E\big[ \vec{s}_t \vec{s}_t^T \biggiven \vec{y}_{1:T} \big]
					\qquad
					\mat{P}_{t, t - 1} \coloneqq \E\big[ \vec{s}_t \vec{s}_{t - 1}^T \biggiven \vec{y}_{1:T} \big]
				\end{align*}
				\begin{align*}
					\hat{\vec{g}}_t \coloneqq \E\big[ \vec{g}(\vec{s}_t) \biggiven \vec{y}_{1:T} \big]
					\qquad
					\mat{G}_t \coloneqq \E\big[ \vec{g}(\vec{s}_t) \, \vec{g}^T\!(\vec{s}_t) \biggiven \vec{y}_{1:T} \big]
				\end{align*}
			\end{frame}
		% end
	% end


	% Classical approach.
	% Interpretation as markov process or hidden markov model.
	% Probabilistic interpretation.
	% Variational approach.
	% EM algorithm.
	% Maximization goal (log-likelihood).
	% Computation via FilterinTaken fromg/Smoothing and SGD.
\end{document}
